# 闭包与变量提升与 this 与 new 那得从 V8 说起

> chrome 版本 114.0.5735.198（正式版本） (arm64) ，控制台特性一直变化，所以需要记录版本

## 编译器与解释器

- 编译型语言：编译成二进制文件，直接执行二进制文件
- 解释型语言：每次运行时都需要通过解释器对程序进行动态解释后执行

JavaScript 属于解释型语言，是逐条解释，逐条执行

![1](/img/interview/3/1.jpg)

但是 V8 不仅仅有解释器，他包含编译器 TurboFan 与解释器 Ignition

![2](/img/interview/3/2.jpg)

V8 采用的是即时编译技术（JIT)：字节码配合解释器和编译器的技术

而字节码是 介于 AST 和机器码之间的一种代码，需要通过解释器将其转换为机器码后才能执行

> V8 一开始并没有字节码，而是直接将 AST 转换为机器码，因为执行机器码的效率非常高效。但是 需要消耗大量的内存来存放机器码。为了解决内存占用问题，V8 团队才大幅重构了引擎架构，引入字节码，

## 执行

JavaScript 的编译执行过程分为两个阶段：预处理期 & 编译执行期。

每次执行到函数（es6 是代码块）时，都会经过这两个阶段来执行

预处理期：

- 词法分析：将代码转化为 Token(语法上不可能再分的、最小的单个字符或字符串) 流，同时创建**执行上下文**
- 语法分析：将 Token 流转化为结构化的 AST(抽象语法树)
- 解释器 Ignition 生成字节码：将 AST 转换成可以执行的字节码

编译执行期：

- 解释器 Ignition 在解释执行字节码的同时，将重复代码交给 编译器 TurboFan 编译为机器码并保存

## 执行上下文与作用域

## 执行上下文

执行上下文是评估和执行 Javascript 代码的环境的一个抽象概念。任何代码在 JavaScript 中运行时，都在执行上下文中运行。

- 全局执行上下文
- 函数执行上下文（es6 后为块级执行上下文）
- eval 执行上下文

执行上下文存储在调用栈（Call Stack）中

全局执行上下文在程序一开始执行就初始化，然后放入调用栈，所以代码一执行已经在全局上下文中了

每一次执行到函数（es6 是代码块）时，就会创建函数(块）执行上下文，然后放入调用栈

V8 会执行这个位于栈顶部的函数(块）执行上下文，执行完后将该函数(块）执行上下文弹出

全局执行上下文直到程序终止前都会存在

执行上下文创建时，会：

> 为了新增块级作用域并兼容变量提升等旧特性，出现了新的定义比如词法环境和变量环境，但是本质并没有太大变化，尽量以 es3 为基础理解

es3:

- 创建变量对象(作用域)(函数内是活动对象 AO，变量对象特指全局变量对象如 window)
- 创建作用域链
- 确定 this 的指向

es6:

- 创建词法环境：变量对象（作用域）与作用域链
- 创建变量环境：与词法环境类似，存储变量 var 提升的内容
- 确定 this 的指向

es2018:

- 创建词法环境：变量对象（作用域）与作用域链与 this
- 创建变量环境：与词法环境类似，存储变量 var 提升的内容
- 很多其他环境暂时不关注

![3](/img/interview/3/3.jpg)

### 变量对象（作用域）和作用域链

因为作用域链就是链接的变量对象，所以变量对象暂时称为作用域

因为都是执行上下文中的，所以也分为这两种（eval 暂不考虑）

- 全局作用域（变量对象 VO）
- 函数（es6 为块级）作用域（活动对象 AO）

JavaScript 采用词法作用域，是在**预处理期**的**词法分析**时随着执行上下文创建

> 静态 (词法) 作用域: 静态作用域在代码的 "词法分析" 阶段就确定。变量的可访问范围取决于源代码, 与程序的执行流程没关系。

全局变量对象是程序一开始执行创建的，所以是未活动的，会直接在作用域栈[[Scopes]]中底部，命名为 Global

而执行到函数（es6 是代码块）时，创建函数(块）执行上下文时会创建活动对象，从栈顶开始查找到使用到的变量（包括词法环境和变量环境)，然后放入活动对象中，再压入作用域栈[[Scopes]]中的最上方，命名为 Closure，也叫做闭包

#### [[Scopes]]

函数目前访问的作用域链

现在在 chrome 控制台可以通过`console.dir`看到作用域链`[[Scopes]]`

是一个类数组的栈结构，作用域栈[Closure,Script,Global]

- Closure：闭包作用域
- Script：Script 标签的作用域（控制台没有标签则没有变量内容)
- Global：全局作用域

```js
const a = 1
function fun() {
  const b = 1
  const p = () => {}
  console.dir(p)
}
fun()
```

并不是所有的父级作用域的变量都进行存储，而只会存储当前函数所使用到的变量

可以看到 p 的 Scopes 中没有 Closure 包含 b

```js
const a = 1
function fun() {
  const b = 1
  const p = () => {
    const c = b
  }
  console.dir(p)
}
fun()
```

而当 p 中使用了 b 后，则产生闭包放入作用域链中

### this

先看一个例子

```js
var bar = {
  myName: 'time.geekbang.com',
  printName: function () {
    console.log(myName)
  },
}

function foo() {
  let myName = '极客时间'
  return bar.printName
}

let myName = '极客邦'

let _printName = foo()

_printName()

bar.printName()
```

因为 JavaScript 是静态作用域，所以这两个打印出来的值都是"极客邦"

但是我们使用面向对象时，经常需要 printName 访问 bar 对象的 myName 属性，并且可以继承复用

所以就有了 this 机制

this 也是在执行上下文中的，所以也分为这两种（eval 暂不考虑）

- 全局执行上下文中的 this
- 函数执行上下文中的 this

全局执行上下文中，在浏览器中，指向 window，严格模式指向 undefined。node 中则更不一样，暂不考虑

函数执行上下文中，在浏览器中，默认情况下调用一个函数也是指向 window 对象，此时可以通过 call/apply/bind 改变指向为需要的 this

注意，嵌套函数中的直接调用的函数也是如此，并不会继承上一个函数的 this，而箭头函数可以继承，这就是为什么推出箭头函数功能

在对象的属性中，指向调用它的对象

```js
function CreateObj() {
  this.name = '极客时间'
}
var myObj = new CreateObj()
```

在构造函数中，JavaScript 引擎做了四件事：

- 创建了一个空对象 tempObj
- 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象
- 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象
- 最后返回 tempObj 对象

相当于代码：

```js
var tempObj = {}
CreateObj.call(tempObj)
CreateObj()
return tempObj
```

## 闭包

简单来说，闭包指的是内部函数引用外部函数的变量的集合

具体的则在上文已经讲过了，在预解释期间，词法分析创建函数执行上下文时，产生的作用域链中，会记录下函数引用到变量了的上级作用域，上级作用域中包含了该函数引用的所有变量，这个作用域就是闭包，没有使用的则不记录，全局环境则全部记录

## 参考资料

- [李兵](https://time.geekbang.org/column/article/131887)
- [冴羽](https://github.com/mqyqingfeng/Blog/issues/4)
- [Scopes](https://note.affi-sapo-sv.com/js-scope.php)
- [es 发展后的执行上下文区别](https://mdnice.com/writing/3674c3b95bc242d19ff9d92257c747d4)

<p align="right">23.08.10</p>
