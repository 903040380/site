# useMemoizedFn 与 useLatest

- useMemoizedFn： 理论上可以替换 useCallback

```ts
type noop = (this: any, ...args: any[]) => any

// https://github.com/alibaba/hooks/pull/1470
type PickFunction<T extends noop> = (
  this: ThisParameterType<T>,
  ...args: Parameters<T>
) => ReturnType<T>

// 返回更新了状态但是地址不变的fn
function useMemoizedFn<T extends noop>(fn: T) {
  // 开发环境日志
  if (isDev) {
    if (!isFunction(fn)) {
      console.error(
        `useMemoizedFn expected parameter is a function, got ${typeof fn}`,
      )
    }
  }

  // 使用useRef获取最新的fn
  const fnRef = useRef<T>(fn)

  // 适配 react devtool
  // why not write `fnRef.current = fn`?
  // https://github.com/alibaba/hooks/issues/728
  fnRef.current = useMemo(() => fn, [fn])

  // 只赋值一次，所以memoizedFn引用不会变化，且始终为最新的fn
  const memoizedFn = useRef<PickFunction<T>>()
  if (!memoizedFn.current) {
    // 这里的第一个参数this是适配eslint的eslint no-invalid-this https://github.com/alibaba/hooks/pull/1464
    memoizedFn.current = function (this, ...args) {
      // 这里是适配函数被对象等调用的情况，防止this指向丢失
      return fnRef.current.apply(this, args)
    }
  }

  return memoizedFn.current as T
}
```

- useLatest

```ts
// 简化ref需要取current的值流程
function useLatest<T>(value: T) {
  const ref = useRef(value)
  ref.current = value

  return ref
}
```

<p align="right">23.08.07</p>
